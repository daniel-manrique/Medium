---
title-block-banner: true
title: "Introduction to spatial analysis of cells for neuroscientists (part 1)"
subtitle: "An approach using point patterns analysis with spatstat"
date: today
date-format: full
author: 
  - name: "Daniel Manrique-Castano"
    orcid: 0000-0002-1912-1764
    degrees:
      - PhD
    affiliation: 
      - name: Univerisity Laval 
        department: Psychiatry and Neuroscience
        group: Laboratory of neurovascular interactions 
note: "GitHub: https://daniel-manrique.github.io/"
keywords: 
  - Spatial analysis
  - Point Pattern Analysis (PPA)
  - Spatial modeling
  
license: "CC BY"

format:
   pdf: 
    toc: true
    number-sections: true
    colorlinks: true
   html:
    code-fold: true
    embed-resources: true
    toc: true
    toc-depth: 2
    toc-location: left
    number-sections: true
    theme: spacelab

knitr:
  opts_chunk: 
    warning: false
    message: false
    
csl: science.csl
bibliography: References.bib
---

# Load libraries and themes

First, let's load the necessary libraries and create a visual theme for our plots.

```{r}
#| label: LoadPack
#| include: true
#| warning: false
#| message: false

library(brms)
library(dplyr)
library(ggplot2)
library(gtsummary)
library(modelr)
library(spatstat)
library(tidybayes)

```

We create a plot theme 

```{r}
#| label: Plot_Theme
#| include: true
#| warning: false
#| message: false
  
Plot_theme <- theme_classic() +
  theme(
      plot.title = element_text(size=18, hjust = 0.5, face="bold"),
      plot.subtitle = element_text(size = 10, color = "black"),
      plot.caption = element_text(size = 12, color = "black"),
      axis.line = element_line(colour = "black", size = 1.5, linetype = "solid"),
      axis.ticks.length=unit(7,"pt"),
     
      axis.title.x = element_text(colour = "black", size = 16),
      axis.text.x = element_text(colour = "black", size = 16, angle = 0, hjust = 0.5),
      axis.ticks.x = element_line(colour = "black", size = 1),
      
      axis.title.y = element_text(colour = "black", size = 16),
      axis.text.y = element_text(colour = "black", size = 16),
      axis.ticks.y = element_line(colour = "black", size = 1),
      
      legend.position="right",
      legend.direction="vertical",
      legend.title = element_text(colour="black", face="bold", size=12),
      legend.text = element_text(colour="black", size=10),
      
      plot.margin = margin(t = 10,  # Top margin
                             r = 2,  # Right margin
                             b = 10,  # Bottom margin
                             l = 10) # Left margin
      ) 
```


As a neuroscientist, in recent years I have been interested in developing strategies that allow multimodal assessment of cell distribution in the brain. My motivation was to quantitatively understand the cellular rearrangement of neuroglia after brain injury. Along the way, I came across `spatstat`[@spatstat], a multifunctional R package for spatial analysis based on point patterns, called point pattern analysis (PPA). This approach is well developed in fields such as geography, epidemiology, or ecology, but applications to neurobiology are very limited, if not non-existent. I recently published a short protocol [@manrique-castano2024], and the reader can find a pre-print [@manrique-castano2023](currently%20under%20revision) with a much longer and dedicated application of this approach.

In this post, my goal is to provide an accessible introduction to the use of this method for researchers interested in unraveling the spatial distribution of cells in different tissues, without the narrative rigidity of scientific papers.

# What is point pattern analysis (PPA)?

PPA is a spatial analysis technique employed to study the distribution of individual events or objects in a given area (also called observation window). This method allow researchers to examine the number of objects per unit area (called spatial intensity), whether the points are randomly distributed, clustered, or regularly spaced; and examine the variations of spatial intensity conditional on different covariants. In contrast to raw and unreproducible cell counts (i.e 100 cells/mm2), PPA maintains all the spatial information and allows multiple and reproducible handling of the point patterns. With this, researchers can identify underlying processes or structures affecting the distribution of the objects of interest. `Spatstat` is a powerful tool for PPA, enabling the visualization and statistical modeling of spatial point data.

# Requirements for PPA

The single requirement to perform PPA is having xy coordinates of single objects (cells, proteins, sub-cellular structures, etc). In this post, we focus on 2D PPA although 3D approaches are also available. Then, this coordinates are handled with R and spatstat function to create point patterns and store them as hyperframes.

I have obtained the coordinates of single cells using unbiased cell detection/quantification approaches using QuPath [@bankhead2017] or CellProfiler [@stirling2021]. I note that the detection and segmentation of round/circular objects like neurons (i.e NeuN) is easier compared to irregular objects like astrocytes (GFAP) or microglia (IBA1), specially when cell density is high and there is a lot of cell overlapping (like glial aggregation after brain injury). The segmentation of irregular, heavily clustered objects is still a frontier in this field. However, the QuPath or CellProfiler offer fair accuracy, and most importantly, are reproducible and can be validated. A human observer could do no better. I recommend, therefore, that you do not worry too much if in some cases you have the impression that certain objects correspond only to fragments of a cell or a combination of several cells. Fine-tune the parameters to assure that the cell detection/segmentation do the best possible job. When the cells are far enough apart (i.e. healthy brain, cell culture), there is not much to worry about.

# Creating point patterns

When working with multiple samples, the creation of point patterns can be simplified using functions like the one in the following [link](https://github.com/elalilab/Stroke_PDGFR-B_Reactivity/blob/main/Widefield_5x_Ipsilateral_Gfap-Pdgfrb_Handling.qmd). The heart of this procedure is the conversion of individual .csv files containing coordinates of single cells into point patterns (using the `ppp` function from `spatstat`) and organize them in a hyperframe that can be stored and share as a .rds R object. 

Here, we'll load a point pattern I have created during my research [@manrique-castano2023]. This file is available in the 
[GitHub repository](https://github.com/daniel-manrique/MediumBlog/tree/main/Data) under the name `PointPatterns_5x.rds`. Please feel free to use it for research, educational, or training purposes. 

```{r}
#| label: LoadData
#| include: true
#| warning: false
#| message: false
#| column: margin

PointPatterns <- readRDS("Data/PointPatterns_5x.rds")
row.names(PointPatterns) <- PointPatterns$ID 

PointPatterns

```
You see that the hyperframe contains different columns with variables. We'll start by focusing on the first three columns, which contain point patterns for three kind of brain cells: Neurons, astrocytes and micriglia. We will rewrite the other variable columns to in our way to implement PPA for research. First, let's take a look how the point patterns looks like by plotting all of them (for neurons) at the same time:

```{r}
#| label: fig-PlotAllPatterns
#| include: true
#| warning: false
#| message: false

plot(PointPatterns$Neurons)
```

Now, let's see the details by looking at any single brain

```{r}
#| label: fig-PlotSinglePatterns
#| include: true
#| warning: false
#| message: false
#| fig-cap: Single point pattern.
#| fig-height: 5
#| fig-width: 6

plot(PointPatterns$Neurons$M05)
```
We can play a little bit with the plots, displaying two cell types (point patterns) at the same type and changing the way (shape and color) they are plotted. Here is an example:

```{r}
#| label: fig-SinglePlot2
#| include: true
#| warning: false
#| message: false
#| fig-cap: Different cells types and aestetics.
#| fig-height: 5
#| fig-width: 6

# We plot neurons in black with symbol (10)
plot(PointPatterns$Neurons$M05, pch = 10, cex = 0.4, main = "Neurons and Astrocytes")

# We add astrocytes in red with a different symbol (18)
plot(PointPatterns$Astrocytes$M05, pch = 18, cex = 0.4, col = "red", add = TRUE)
```
This allows a first impression of the number and distribution of the cells, but sure, we need to quantify it. A first approach is to obtain the estimated spatial intensity for each point pattern. We can generate an additional column for each row in the hyperframe with a simple code. For the sake of this post, we do it just for astrocytes:

```{r}
#| label: CreateSpatialIntensity
#| include: true
#| warning: false
#| message: false

PointPatterns$AstrocytesIntensity <- with(PointPatterns, summary(Astrocytes)$intensity)

PointPatterns
```
You can see that we generated a new column containing the astrocyte spatial intensity. WE can extract that information into a data frame toguther with the grouping variables:

```{r}
#| label: CreateDataframe_Intensity
#| include: true
#| warning: false
#| message: false

Astrocytes_df <- as.data.frame(PointPatterns[,9:11])

# We make sure to organize our factor variable in the right order
Astrocytes_df$DPI <- factor(Astrocytes_df$DPI, levels = c("0D", "5D", "15D", "30D"))

gt::gt(Astrocytes_df[1:10,])
```

This is a good start, you are able to get the number of cells per unit area in a reproducible way, using unbiased/automatic cell counting. Let's do a simple scientific inference from this data.

# Fit a statistical model for the spatial intensity

As customary in my blog, we use `brms` [@brms] to fit a Bayesian linear model where we investigate the Astrocyte spatial intensity conditioning on DPI, that is, the days post-ischemia (brain injury) for the animals in this data set. We'll create a model with heteroskedasticity (predicting sigma), as (I know) the variance between the DPIs is not the same. It is much smaller for 0D. 

```{r}
#| label: Astrocytes_Fit
#| include: true
#| warning: false
#| message: false

Astrocytes_Mdl <- bf(AstrocytesIntensity ~ DPI, 
                     sigma ~ DPI)
  
Astrocytes_Fit <- brm(formula = Astrocytes_Mdl,
                      family = student,
                      data = Astrocytes_df, 
                      # seed for reproducibility purposes
                      seed = 8807,
                      control = list(adapt_delta = 0.99),
                      # this is to save the model in my laptop
                      file    = "Models/2024-05-24_PPA/Astrocytes_Fit.rds",
                      file_refit = "never")

# Add loo for model comparison
Astrocytes_Fit <- 
  add_criterion(Astrocytes_Fit, c("loo", "waic", "bayes_R2"))
```
Let's look at the summary table for our model:

```{r}
#| label: Lm_summary
#| include: true
#| warning: false
#| message: false

summary(Astrocytes_Fit) 
```
We see that animals at 0D (Intercept) have a mean spatial intensity of 4.3 with 95% credible interval (CI) between 0.73 and 2.90. That's a very low amount of cells. On the other side, we have a peak at 15D with a mean of 26.9 with CIs between 22-31. 

Let's plot the results using the great `TidyBayes` package [@tidybayes] by the great [Matthew Kay](https://www.mjskay.com/)

```{r}
#| label: fig-AstrocytesResults
#| include: true
#| warning: false
#| message: false
#| fig-cap: Posterior distribution for the spatial intensity of astrocytes.
#| fig-height: 5
#| fig-width: 6

Astrocytes_df %>%
  data_grid(Astrocytes_df) %>%
  add_epred_draws(Astrocytes_Fit) %>%
  ggplot(aes(x = .epred, y = DPI)) +
  labs(x = "Spatial intensity") +
  stat_halfeye() +
  geom_vline(xintercept = 0) +
  Plot_theme
```

`stat_halfeye()` is an appealing way of looking at the results. This procedure is analogous to counting cells in a given area. The advantage of PPA is that you do not need to trust on the supposed visual acuity of a student counting cells (the supposed experts are not the ones counting them) but can produce unbiased cell counting which can be validated and are reproducible and reusable. Definitively, we can do a lot more with PPA.

# Creating density kernels

We have density kernels available in the loaded point patterns, but we'll rewrite them for the purposes of this post. A density kernel, is a method to estimate the probability density function of a variable, in this case, position of cells. This provides a smooth estimate of the intensity function that generated the observed data. 

The kernel density estimation for point patterns can be formulated as follows:

$$
\hat{\lambda}(u) = \frac{1}{n}\sum_{i=1}^{n} K_h(u - x_i)
$$ {#eq-DensityKernel}

Where:

-   $\hat{\lambda}(u)$ is the estimated intensity function at location $u$.

-   $n$ is the number of points.

-   $x_i$ is the location of the $i$-th point.

-   $K_h(u - x_i)$ is the kernel function scaled by the bandwidth $h$.

We'll recreate the density kernels for astrocytes and microglia using the `density` function from `spatstat`. Please make sure this function is not overwrote by other packages. I judge that a sigma (bandwidth) of 0.2 offers a fair readout for the point pattern density. 

```{r}
#| label: CreateKernels
#| include: true
#| warning: false
#| message: false

PointPatterns$Astrocytes_Dens <- with(PointPatterns, density(Astrocytes, sigma = 0.2, col = topo.colors))

```

With this ready, I want to offer you and example of the impact of sigma in the density kernel using a single brain

```{r}
#| label: SampleKernels
#| include: true
#| warning: false
#| message: false
#| fig-cap: Density kernels with different sigma.
#| fig-height: 6
#| fig-width: 15

par(mfrow = c(1,3), mar=c(1,1,1,1), oma=c(1,1,1,1))

plot(density(PointPatterns$Astrocytes$M05, sigma = 0.02), col = topo.colors, main = "sigma = 0.02")
plot(density(PointPatterns$Astrocytes$M05, sigma = 0.2), col = topo.colors, main = "sigma = 0.2")
plot(density(PointPatterns$Astrocytes$M05, sigma = 2), col = topo.colors, main = "sigma = 2")
```
In the first case, we see that a very low sigma maps individual points. For sigma = 0.2, we see a mapping on a larger scale, and we can differentiate much better regions with low and high density of astrocytes. Finally, sigma = 2 offers a perspective where we cannot really discriminate with precision de different densities of astrocytes. For this case, sigma = 0.2 offer a good compromise. 

Now, we'll fit a simple point process model to investigate the relative distribution of neurons conditioning on the astrocyte density (mapped by the density kernel).

# Fit a point process model (ppm)

Here, we use the `mppm` function from `spatstat` to fit a multiple point process model for the point patterns in our hyperframe.Unfortunately, there are not Bayesian-like functions for multiple point patterns in `spatstat`. 

```{r}
#| label: Neurons_ppm
#| include: true
#| warning: false
#| message: false

# We fit the mppm model
Neurons_ppm <- mppm(Neurons ~ Astrocytes_Dens, data = PointPatterns)

# We check the results
summary(Neurons_ppm)
```
Remember that spatial model are fitted using a Poisson distribution, which uses the log link function to obtain only positive results. This means we need to exponentiate the results in the table to convert them to the original scale. Therefore, we can grasp that the spatial intensity of neurons at a baseline (when the density of astrocytes is 0) is exp(3.54) = 34.4. This intensity decreases by ex(-0.002171358) -0.99 for each unit astrocyte spatial intensity (defined by the density kernels) increases. In other words, this model tells us that we have less neurons in points where we have more astrocytes. Noe that we are not considering DPI into the regression, an excercise you can perform to see if this estimation changes by DPI. 

There are more aspect to explore for PPA. However, not to make this post long and heavy, I will cover them in teo next post. Here, you could get how to calculate and extract the spatial intensity of cells, create density kernels and build point process models using them. In the next post, we'll explore how to perform calculations for relative distributions and the use of raster layers to further explore the cell distribution. 

I would appreciate your comments or feedback letting me know if this journey was useful to you. If you want more quality content on data science and other topics, you might consider becoming a [medium member](https://medium.com/membership).

You can find a complete/updated version of this post on my [GitHub site](https://github.com/daniel-manrique/MediumBlog/blob/main/2024-04-19_CountsZeroInflated.qmd).

-   All images, unless otherwise stated, were generated using the displayed R code.

# References

::: {#refs}
:::

```{r}
sessionInfo()
```
